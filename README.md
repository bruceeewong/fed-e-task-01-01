# Part1 JavaScript 深度剖析 - 模块 1 ES 新特性&JS 异步编程&TypeScript

> 项目: 拉勾大前端训练营作业一
>
> 作者: bruski
>
> 时间：2020/05/23

## 简答题

### 1 说明执行结果与原因

```js
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}

a[6]();
```

答案与解释：

```js
a[6]() === 10;
```

1. 因为在循环中使用 `var` 关键字创建的 `i` 变量是全局作用域下的变量
2. 循环结束后，全局的`i`自增为 10， 那么运行 `a[6]()` 打印的是此时全局变量`i`的值，即 `10`

### 2 说明执行结果与原因

```js
var tmp = 123;

if (true) {
  console.log(tmp);
  let tmp;
}
```

答案与解释：

打印的是 `123`。

1. 定义了全局环境的变量 `tmp` 值为 `123`
2. 判断体内的 `let tmp` 由于不会有变量提升，所以`console.log`打印的是全局变量的`tmp`值，即 `123`

### 3 ES6 语法用最简单的方式找到数组中的最小值

```js
var arr = [12, 34, 32, 89, 4];
```

答案：

```js
const [min] = arr.sort((a, b) => a - b);
```

### 4 请详细说明 var, let, const 三种声明变量方式之间的具体差别

三者之间比较：

1. 从变量的**作用域**来讲，`let`与`const`会为变量创建 **块级作用域**, `var`只能创建全局/函数作用域的变量
2. 从变量的**声明提升**来讲，`var`会将变量提升至当前模块的顶部，所有位置均可访问; 而`let`与`const`不会提升，尝试提前访问变量会报未定义错误

`let`与`const`之间比较:

1. `let`可以先声明变量，再赋值，且后续可以更改
2. `const`必须在创建变量时定义值，
   2.1 如果是基础类型，后续不可修改该变量的值
   2.2 如果是引用类型，后续不可修改该变量的引用(内存地址)，但可以修改对象属性的值(该内存地址所存放的数据)

### 5 说明执行结果与原因

```js
var a = 10;

var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a);
    });
  },
};

obj.fn();
```

答案及解释

```js
obj.fn() === 20;
```

1. 首先看最终的调用情况，是`obj`对象调用的`fn`方法，那么此时`fn`方法中的`this`指向的是`obj`对象
2. `fn`方法中`setTimeout()`的回调函数使用了箭头函数，则此回调函数的作用域绑定为当前执行环境作用域，回调函数的`this`也将指向`fn`的`this`，即`obj`对象
3. 综上所述, 打印的是 `this.a` 即 `obj.a`，值为 `20`

### 6 简述 Symbol 类型的用途

1. 创建独一无二的值，如可用于生成 id
2. Symbol 配合对象的计算属性，可用作模块中对象的私有属性
3. Symbol 中的内置属性可用于重写对象的内置方法

### 7 什么是浅拷贝，什么是深拷贝?

首先浅拷贝和深拷贝都是指对于对象复制，当对象属性中含有别的对象引用的场景

浅拷贝是指：

1. 只复制源对象的属性与值，对于引用类型，复制的值是指内存地址。
2. 表现在外部是，修改了复制对象的引用属性的值后，会影响源对象中引用类型属性的值。

深拷贝是指：

1. 复制源对象的属性与值，并且对于引用类型的属性，递归执行拷贝，返回的对象，值相同、但引用的地址是新的。
2. 表现在外部是，修改了复制对象的引用属性的值后，不会影响源对象中引用类型属性的值。

### 8 如何理解 JS 异步编程, Event Loop 是做什么的, 什么是宏任务, 什么是微任务

由于 JavaScript 是单线程执行的，我们希望将耗时的任务放到别的线程中运行，就需要运行异步任务。而单线程要实现异步模式，要借助一种定义好成功或失败时的逻辑，并交给执行者在恰当的时机执行的机制。

js 可以将函数作为参数传递的特性，在任务发起方定义函数，由执行者选择时机执行，即`回调函数`。

所以 JS 异步编程就是结合`回调函数`以及`事件发布订阅`机制，在 JS 主线程与其他异步任务线程中间，设置`消息队列`的结构存储异步执行完的回调结果，再由主线程去执行回调结果。

`Event Loop`就是指的 JS 执行同步任务与异步任务的整个过程，它负责 **监听 JS 线程`Call Stack`是否为空， 若为空， 就去`消息队列`将出队的回调传给 JS 线程去执行**，循环往复。

`宏任务`可以理解为：回调结果为会被压入消息队列的异步任务，会在当前任务的下一轮开始执行

`微任务`可以理解为：回调结果将在本轮同步任务执行完的末尾，立即执行；不会进入消息队列。

### 9 异步代码使用 Promise 改进

```js
setTimeout(function () {
  var a = "hello";
  setTimeout(function () {
    var b = "lagou";
    setTimeout(function () {
      var c = "I ❤️ U";
      console.log(a + b + c);
    }, 10);
  }, 10);
}, 10);
```

答案：

```js
const promise1 = new Promise((resolve) => {
  setTimeout(() => {
    resolve("hello");
  }, 10);
});

const promise2 = new Promise((resolve) => {
  setTimeout(() => {
    resolve("lagou");
  }, 10);
});

const promise3 = new Promise((resolve) => {
  setTimeout(() => {
    resolve("I ❤️ U");
  }, 10);
});

Promise.all([promise1, promise2, promise3]).then((res) => {
  const [a, b, c] = res;
  console.log(a + b + c);
});
```

### 10 简述 TypeScript 与 JavaScript 的关系

TypeScript 是 JavaScript 的超集，等于 JavaScript + 类型系统

TypeScript 可以运行任意 JS 代码，在编译器的帮助下可以设置类型注解、使用 ES 新特性、使用 TS 独有数据类型，检查类型错误。

最终通过编译器将 TS 代码转为 JS 代码。

### 11 你认为 TypeScript 的优缺点?

优点：

1. 设置类型注解与静态编译器检查，消除了 JS 弱类型的带来的运行时不确定性，对应用的稳定和 debug 有帮助
2. 可以使用最新的 ECMAScript 特性
3. 可以使用 TS 的新类型与方法，如接口、枚举，拥有更加完善地面向对象编程能力
4. 生态好，大势所趋

缺点：

1. 存在学习门槛和成本
2. 配置编译器、脚手架需要掌握 node 知识
3. 对于小项目，可能过于繁重
